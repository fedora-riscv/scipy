commit 09d753f0ae71441906f5cee7a44b2d2b80212082
Author: Nikola Forr√≥ <nforro@redhat.com>
Date:   Thu Jan 14 14:34:14 2021 +0100

    ENH: Support big-endian platforms and big-endian WAVs
    
    PR #12287 added support for reading arbitrary-bit-depth WAVs, but
    the code doesn't consider big-endian WAVs, and doesn't work as expected
    on big-endian platforms due to the use of native-byte-order data-types.
    This change fixes that.
    
    There is also a simple test case that compares euqivalent RIFX
    (big-endian) and RIFF (little-endian) files to verify the data read
    are the same.

diff --git a/scipy/io/wavfile.py b/scipy/io/wavfile.py
index 9b5845d6b..951f8d201 100644
--- a/scipy/io/wavfile.py
+++ b/scipy/io/wavfile.py
@@ -458,10 +458,13 @@ def _read_data_chunk(fid, format_tag, channels, bit_depth, is_big_endian,
 
         if dtype == 'V1':
             # Rearrange raw bytes into smallest compatible numpy dtype
-            dt = numpy.int32 if bytes_per_sample == 3 else numpy.int64
-            a = numpy.zeros((len(data) // bytes_per_sample, dt().itemsize),
+            dt = f'{fmt}i4' if bytes_per_sample == 3 else f'{fmt}i8'
+            a = numpy.zeros((len(data) // bytes_per_sample, numpy.dtype(dt).itemsize),
                             dtype='V1')
-            a[:, -bytes_per_sample:] = data.reshape((-1, bytes_per_sample))
+            if is_big_endian:
+                a[:, :bytes_per_sample] = data.reshape((-1, bytes_per_sample))
+            else:
+                a[:, -bytes_per_sample:] = data.reshape((-1, bytes_per_sample))
             data = a.view(dt).reshape(a.shape[:-1])
     else:
         if bytes_per_sample in {1, 2, 4, 8}:
